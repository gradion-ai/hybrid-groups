{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#overview","title":"Overview","text":"<p>Hybrid Groups is a multi-user, multi-agent platform that enables teams to collaborate with proactive and reactive agents in Slack and GitHub. It adds background reasoning to Slack threads and GitHub issues to intelligently activate agents based on chat messages and context. Agents reason, act and respond specific to a user's identity, preferences and history, and can take actions on behalf of a user. In Slack, users can build custom agents with a simple agent builder. More advanced agents or agentic systems can be integrated with the Hybrid Groups Python SDK.</p> <p>Figure 1: A Hybrid Groups thread in Slack.</p> <p>Figure 2: The Hybrid Groups Slack app home view.</p> <p>Figure 3: A Hybrid Groups thread in GitHub.</p>"},{"location":"#features","title":"Features","text":"Feature Example Description Group sessions In Hybrid Groups, users and agents collaborate in group sessions. A group session corresponds to a thread in Slack or an issue in GitHub. Agents have the full context of their session, seeing all messages, senders, and receivers. Each session runs their own instances of agents and background reasoners to isolate them from other sessions. To include context from other sessions, Hybrid Groups supports session references, e.g. via issue references in GitHub issues. Background reasoning The system analyzes messages to determine if an agent could contribute to a conversation without being mentioned, allowing for proactive assistance. For example, if two users discuss a topic, a search agent may proactively provide context information. This process is guided by an agent activation policy (example) and its status is indicated with emoji reactions on user messages:  reasoning started,  agent activated, and  no further action. On GitHub, the corresponding emojis are , , and . Agent activation Agents can be activated either via background reasoning or by directly mentioning an agent at the beginning of a user message. Mentioning an agent bypasses background reasoning, resulting in lower response latencies. Identity-aware actions Agents can perform actions on behalf of specific users by executing tools with the requesting user's identity and permissions. Users provide secrets, such as API keys, to authorize agents to securely access private resources. These secrets are encrypted at rest and are never shared across users. Action approval Tool execution can be approved once, for the duration of a session or permanently on a per-user basis. A permission request is sent to a user via a private channel. In Slack, for example, a permission request is sent as ephemeral message that is only visible to the user who triggered the execution. User preferences Users can set preferences in plain English to personalize how agents interact with them. Agents respect these settings for every user in a session, tailoring their behavior and response style to each person's preferences. Task handoff Agents can be configured to handoff tasks to other, more specialized agents in the registry. User context is preserved during a handoff, or even a chain of handoffs. For example, in a handoff chain <code>User 1 -&gt; Agent A -&gt; Agent B -&gt; Agent C</code>, <code>Agent C</code> still acts on behalf of the <code>User 1</code>. Agent builder The Slack app includes a simple agent builder to create and edit agents from the app's home view. Users can build custom agents by defining their system prompt, model, tools, and criteria for for being activated by background reasoning. For integrating more advanced agents or agentic systems, use the Hybrid Groups Python SDK. Python SDK The Slack and GitHub integrations are built on our Python SDK, which provides the building blocks for developing custom multi-user, multi-agent applications. For interacting with agents, it defines an <code>Agent</code> abstraction that we currently implement with Pydantic AI but it can be replaced with other implementations if desired. Session persistence Group sessions are saved, so they can be resumed after a server restart. This includes all messages and the states of agents and background reasoners. Messages added by users in Slack or GitHub while the server is down are synchronized when sessions are resumed."},{"location":"agent-builder/","title":"Agent builder","text":""},{"location":"agent-builder/#agent-builder","title":"Agent builder","text":"<p>The Hybrid Groups Slack app includes a simple agent builder at the bottom of the app's home view. From there, you can open the agent editor by clicking the <code>Add Agent</code> button or by selecting <code>Edit</code> from an agent's menu. </p> <p>Figure 1: Agent configuration sections in the Hybrid Groups Slack app home view.</p> <p>Figure 2: Editor for configuring the system prompt, model and tools of an agent.</p> <p>In the editor, users can build custom agents by defining their system prompt, model and tools. An agent's description and the agent activation policy (example) determine if an agent is activated by background reasoning.</p> <p>Advanced agents</p> <p>For integrating more advanced agents or agentic systems, use the Hybrid Groups Python SDK.</p>"},{"location":"agent-builder/#model","title":"Model","text":"<p>The model is specified with a PydanticAI model name.</p> <pre><code>\"gemini-2.5-flash\"\n</code></pre>"},{"location":"agent-builder/#model-settings","title":"Model Settings","text":"<p>Model settings can be common model settings or specific to a given provider. The following example shows settings for Google Gemini.</p> <pre><code>{\n  \"google_thinking_config\": {\n    \"thinking_budget\": 2048\n  }\n}\n</code></pre>"},{"location":"agent-builder/#mcp-settings","title":"MCP settings","text":"<p>MCP settings are defined as a JSON array of MCP server configurations. In <code>env</code> or <code>headers</code>, you can use placeholders for values e.g. <code>${VAR_NAME}</code>. These will be substituted at runtime with user secrets or environment variables.</p> <pre><code>[\n  {\n    \"server_config\": {\n      \"command\": \"npx\",\n      \"args\": [\n        \"-y\",\n        \"@modelcontextprotocol/server-brave-search\"\n      ],\n      \"env\": {\n        \"BRAVE_API_KEY\": \"${BRAVE_API_KEY}\"\n      }\n    },\n    \"session_scope\": false\n  }\n]\n</code></pre> <p>The <code>session_scope</code> setting determines the lifecycle of an MCP server and how placeholders are substituted:</p> <ul> <li><code>session_scope: true</code>: The server is started once per session and reused across requests (session scope). This is the recommended and most performant option. It supports substituting placeholders with environment variables.</li> <li><code>session_scope: false</code>: A new server is started for each agent request (request scope). This may be less performant but is required if you need to substitute placeholders with user secrets. It also supports substituting placeholders with environment variables.</li> </ul> <p>Hint</p> <p>The <code>reader</code> and <code>zotero</code> agents in the screenshot above use the readwise-reader-mcp and zotero-mcp servers, respectively. To use them, follow their installation instructions and set the <code>READER_MCP_EXEC</code> and <code>ZOTERO_MCP_EXEC</code> environment variables as required by demo/register_agents.py.</p>"},{"location":"agent-builder/#python-coroutines","title":"Python coroutines","text":"<p>You can configure <code>async</code> Python functions as tools for an agent by specifying their <code>module</code> and <code>function</code> name.</p> <pre><code>[\n  {\n    \"module\": \"examples.weather\",\n    \"function\": \"get_weather_forecast\"\n  }\n]\n</code></pre>"},{"location":"app-server/","title":"App server","text":""},{"location":"app-server/#slack","title":"Slack","text":"<p>To serve the Slack app, run:</p> <pre><code>python -m hygroup.scripts.server --gateway slack\n</code></pre> <p>This auto-approves all tool executions. To enable manual approval of tool executions via ephemeral messages use the <code>--user-channel slack</code> option:</p> <pre><code>python -m hygroup.scripts.server --gateway slack --user-channel slack\n</code></pre> <p>Alternatively, use a terminal-based, separate user channel:</p> <pre><code>python -m hygroup.scripts.server --gateway slack --user-channel terminal\n</code></pre>"},{"location":"app-server/#github","title":"GitHub","text":"<p>To serve the GitHub app, run:</p> <pre><code>python -m hygroup.scripts.server --gateway github\n</code></pre> <p>The GitHub app server additionally requires a smee.io channel for webhook payload delivery. A channel is generated during the GitHub app setup and stored in the <code>.env</code> file as <code>GITHUB_APP_WEBHOOK_URL</code>. To connect to the channel, install the smee client and run:</p> <pre><code>source .env \\\n&amp;&amp; smee -u $GITHUB_APP_WEBHOOK_URL -t http://127.0.0.1:8000/api/v1/github-webhook\n</code></pre> <p>This auto-approves all tool execution permissions. In contrast to Slack, the GitHub integration doesn't include a built-in user channel for approving tool execution permissions. The only option is a terminal-based, separate user channel:</p> <pre><code>python -m hygroup.scripts.server --gateway github --user-channel terminal\n</code></pre>"},{"location":"app-server/#terminal","title":"Terminal","text":"<p>To serve a terminal-based chat client, for demonstration or testing purposes, run:</p> <pre><code>python -m hygroup.scripts.server --gateway terminal\n</code></pre> <p>Then start the client with</p> <pre><code>python -m hygroup.scripts.client --username &lt;username&gt;\n</code></pre> <p>where <code>&lt;username&gt;</code> is a username of your choice or a registered username. If registered with a user password, provide the same password at login, otherwise leave it empty.</p>"},{"location":"app-server/#separate-user-channel","title":"Separate user channel","text":"<p>A terminal-based, separate user channel for approving tool execution can be established by starting the app server with the <code>--user-channel terminal</code> option and then a channel client with:</p> <pre><code>python -m hygroup.scripts.channel --username &lt;username&gt;\n</code></pre> <p>where <code>&lt;username&gt;</code> is</p> <ul> <li>a Slack member id (e.g. <code>U061F7AURQ6</code>) when running the app server with <code>--gateway slack</code></li> <li>a GitHub username when running the app server with <code>--gateway github</code></li> <li>a matching username when running the app server with <code>--gateway terminal</code></li> <li>a registered username when running the app server with any <code>--gateway</code> argument</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#python-package","title":"Python package","text":"<pre><code>pip install hybrid-groups\n</code></pre>"},{"location":"installation/#development-environment","title":"Development environment","text":"<pre><code>git clone https://github.com/gradion-ai/hybrid-groups.git\ncd hybrid-groups\nconda env create -f environment.yml\nconda activate hybrid-groups\npoetry install\n</code></pre> <p>Find more details in DEVELOPMENT.md.</p>"},{"location":"installation/#slack-app","title":"Slack app","text":"<p>To set up and install the Hybrid Groups Slack app to your workspace, run:</p> <pre><code>python -m hygroup.setup.apps slack\n</code></pre> <p>This will add the following variables to your <code>.env</code> file:</p> .env<pre><code>SLACK_BOT_TOKEN=...\nSLACK_APP_TOKEN=...\nSLACK_APP_ID=...\n</code></pre> <p>After setup, you must manually add the app to any Slack channels you want it to be active in. You can do this from the channel's menu under <code>Open channel details</code> -&gt; <code>Integrations</code> -&gt; <code>Add apps</code>.</p>"},{"location":"installation/#github-app","title":"GitHub app","text":"<p>To set up and install the Hybrid Groups GitHub app in one or more repositories, run:</p> <pre><code>python -m hygroup.setup.apps github\n</code></pre> <p>This will add the following variables to your <code>.env</code> file:</p> .env<pre><code>GITHUB_APP_ID=...\nGITHUB_APP_USERNAME=...\nGITHUB_APP_CLIENT_SECRET=...\nGITHUB_APP_WEBHOOK_SECRET=...\nGITHUB_APP_PRIVATE_KEY_PATH=...\nGITHUB_APP_INSTALLATION_ID=...\nGITHUB_APP_WEBHOOK_URL...\n</code></pre>"},{"location":"python-sdk/","title":"Python SDK","text":"<p>Warning</p> <p>The Hybrid Groups Python SDK is still experimental, do not use it in production.</p> <p>Note</p> <p>Documentation of the Python SDK is work in progress ...</p> <p>Refer to the following resources for representative usage examples of the SDK:</p> <ul> <li>Application server. Demonstrates how to assemble SDK components to an application server that serves the Slack, GitHub and Terminal apps.</li> <li>Agent registration. Demonstrates how to configure and register agents. Defines simple agents used in the introductory examples. </li> </ul>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Docker</p> <p>As an alternative to a local environment setup, use our Docker container to install and run the Slack and GitHub apps:</p> <ol> <li> <p>Setup the app (prints the setup URL to follow in the output) - only required once per app: <pre><code>docker run --rm -it \\\n  -v \"$(pwd)/.data-docker\":/app/.data \\\n  -p 8801:8801 \\\n  ghcr.io/gradion-ai/hybrid-groups:latest \\\n  setup &lt;slack | github&gt;            \n</code></pre> Important: when running the container on a remote host, supply the hostname or IP address via the <code>--host</code> parameter. After setting up the Slack app, add it to any Slack channels you want it to be active in. You can do this from the channel's menu under <code>Open channel details</code> -&gt; <code>Integrations</code> -&gt; <code>Add apps</code>.</p> </li> <li> <p>Run the server: <pre><code>docker run --rm -it \\\n  -v \"$(pwd)/.data-docker\":/app/.data \\\n  ghcr.io/gradion-ai/hybrid-groups:latest \\\n  server &lt;slack | github&gt;\n</code></pre> To enable user channels in Slack, append the <code>--user-channel slack</code> option.</p> </li> <li> <p>Verify with a usage example that your installation works.</p> </li> </ol>"},{"location":"quickstart/#app-installation","title":"App installation","text":"<p>Follow the installation instructions for setting up a development environment and installing the Slack and GitHub apps.</p>"},{"location":"quickstart/#gemini-api-key","title":"Gemini API key","text":"<p>A GEMINI_API_KEY is required for background reasoning and by demo agents. Place it in a <code>.env</code> file in the project's root directory.</p> .env<pre><code>GEMINI_API_KEY=...\n</code></pre>"},{"location":"quickstart/#agent-registration","title":"Agent registration","text":"<p>Register example agents by running the following command. Without any additional API keys, this will add agents <code>general</code> and <code>weather</code> to the agent registry.</p> <pre><code>python demo/register_agents.py\n</code></pre> <p>Hint</p> <p>Other agents in the demo/register_agents.py script require additional API keys for running their MCP servers. These can be added to <code>.env</code> if sharing API keys among users is acceptable. For running MCP servers with user-specific API keys, users need to add them as user secrets in the Slack app's home view or via user registration.</p>"},{"location":"quickstart/#app-server","title":"App server","text":"<p>To serve the Slack app, run:</p> <pre><code>python -m hygroup.scripts.server --gateway slack\n</code></pre> <p>To serve the GitHub app, run:</p> <pre><code>python -m hygroup.scripts.server --gateway github\n</code></pre> <p>The GitHub app server additionally requires a smee.io channel for webhook payload delivery. A channel is generated during the GitHub app setup and stored in the <code>.env</code> file as <code>GITHUB_APP_WEBHOOK_URL</code>. To connect to the channel, install the smee client and run:</p> <pre><code>source .env \\\n&amp;&amp; smee -u $GITHUB_APP_WEBHOOK_URL -t http://127.0.0.1:8000/api/v1/github-webhook\n</code></pre>"},{"location":"quickstart/#usage-example","title":"Usage example","text":"<p>Activate the <code>weather</code> agent via background reasoning by entering e.g.</p> <pre><code>how's the weather in vienna?\n</code></pre> <p>in the channel where the Slack app was added</p> <p>or in the description of a new GitHub issue:</p> <p>For directly mentioning the <code>weather</code> agent in Slack, use <code>@weather</code> at the beginning of a message, in GitHub use <code>@hybrid-groups/weather</code> (and replace <code>hybrid-groups</code> with the GitHub app name you've chosen).</p>"},{"location":"user-registry/","title":"User registry","text":"<p>The app server automatically maintains a user registry for storing user secrets. Manual registration of users is optional but can be useful in the following cases:</p> <ul> <li>Mapping a Slack and GitHub username to a common Hybrid Groups username. The backend then uses this common username for message sender and receiver identification.</li> <li>Secure login with a common username and a user pasword into a terminal-based user channel or chat client.</li> </ul> <p>To start user registration, run:</p> <pre><code>python -m hygroup.scripts.register\n</code></pre> <p>Then follow the instructions for providing</p> <ul> <li>a common username and an optional user password</li> <li>user secrets in the format <code>KEY=VALUE</code> (optional)</li> <li>Slack and GitHub usernames (for user mapping)</li> </ul>"},{"location":"prompts/policy/","title":"Agent activation policy","text":"<pre><code>You are an intelligent routing agent. Your primary function is to analyze messages in a multi-user, multi-agent group chat and determine if a specialized agent should be activated to respond. You must follow the rules below precisely.\n\n## **Your Task**\n\n1. **Analyze the incoming message:** You will receive the last message from a group chat. The message will be in the following XML format:\n\n   ```xml\n   &lt;message sender=\"sender_name\" receiver=\"receiver_name\"&gt;\n   message_content\n   &lt;/message&gt;\n   ```\n\n2. **Consult available agents:** Use the get_registered_agents() tool to get a list of available agents and their descriptions. This is your only knowledge of which agents exist.\n3. **Decide and Respond:** Based on the message content, sender, and the list of available agents, decide if one agent should be activated. Your response **MUST** be a single JSON object with the following structure:\n   **To activate an agent:**\n   ```json\n   {\n       \"agent_name\": \"selected_agent_name\",\n       \"query\": \"a clear and concise query for the agent\",\n   }\n   ```\n   **To skip activation:**\n   ```json\n   {\n       \"agent_name\": null,\n       \"query\": null,\n   }\n   ```\n\n## **Strict Constraints (Non-negotiable Rules)**\n\nYou **MUST** skip activation (\"agent_name\": null) if any of the following conditions are met:\n\n1. **Sender is an Agent:** The sender is one of the names returned by get_registered_agents().\n2. **Sender is \"system\":** The sender attribute is exactly \"system\".\n3. **Direct Agent Mention:** The message_content starts by directly mentioning an agent's name (e.g., @agent_name or agent_name:). This is handled by a different system, so you must ignore it.\n\n## **Selection Rules (Your Decision Logic)**\n\nFollow these principles when deciding whether to select an agent:\n\n1. **Identify Strong Information Need:**\n   * Only activate an agent if the user's message shows a clear, strong need for information or assistance.\n   * This can be an **explicit question** (e.g., \"How do I do X?\", \"What is Y?\").\n   * It can also be an **implicit need**, such as a user expressing confusion, asking for a summary, requesting data, or needing a complex task to be performed.\n   * Do not activate an agent for simple conversational chat, opinions, or social messages.\n2. **Ensure Strong Agent Match:**\n   * The user's identified need must be a very good match for the description of one of the available agents.\n   * If the need is vague or doesn't align well with any agent's capabilities, do not select an agent. It's better to skip than to select the wrong agent.\n3. **Formulate a High-Quality Query:**\n   * If you select an agent, the query you create should be a concise instruction or question that directs the agent's focus. The agent has access to the conversation history, so the query should state the immediate task, relying on the available context.\n</code></pre>"}]}