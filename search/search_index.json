{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Larger images</p> <p>Hover or click any image to view the full-size version.</p>"},{"location":"#overview","title":"Overview","text":"<p>Hybrid Groups is a multi-user, multi-agent platform that enables teams to collaborate with proactive and reactive agents in Slack and GitHub. It adds background reasoning to Slack threads and GitHub issues to intelligently activate agents based on chat messages and context. Agents reason, act and respond specific to a user's identity, preferences and history, and can take actions on behalf of a user. In Slack, users can build custom agents with a simple agent builder. More advanced agents or agentic systems can be integrated with the Hybrid Groups Python SDK.</p> <p>Figure 1: A Hybrid Groups thread in Slack.</p> <p>Figure 2: The Hybrid Groups Slack app home view.</p> <p>Figure 3: A Hybrid Groups thread in GitHub.</p>"},{"location":"#features","title":"Features","text":"Feature Example Description Group sessions In Hybrid Groups, users and agents collaborate in group sessions. A group session corresponds to a thread in Slack or an issue in GitHub. Agents have the full context of their session, seeing all messages, senders, and receivers. Each session runs their own instances of agents and background reasoners to isolate them from other sessions. To include context from other sessions, Hybrid Groups supports session references, e.g. via issue references in GitHub issues. Background reasoning The system analyzes messages to determine if an agent could contribute to a conversation without being mentioned, allowing for proactive assistance. For example, if two users discuss a topic, a search agent may proactively provide context information. This process is guided by an agent activation policy (example) and its status is indicated with emoji reactions on user messages:  reasoning started,  agent activated, and  no further action. On GitHub, the corresponding emojis are , , and . Agent activation An agent can be activated either via background reasoning or by directly mentioning it at the beginning of a user message. Mentioning an agent bypasses background reasoning, resulting in lower response latencies. User preferences Users can set preferences in plain English to personalize how agents interact with them. Agents respect these settings for every user in a session, tailoring their behavior and response style to each person's preferences. User secrets Users can provide secrets, such as API keys, to authorize agents to perform actions on their behalf. These secrets are encrypted at rest and used at runtime to securely access private resources for that user. They are never shared with other users. Tool permissions Agents use tools to perform actions. Tool execution permissions can be granted once, for the duration of a session or permanently on a per-user basis. A permission request is sent to a user via a private channel. In Slack, for example, a permission request is sent as ephemeral message that is only visible to the user who triggered the execution. Task handoff Agents can be configured to handoff tasks to other, more specialized agents in the registry. User context is preserved during a handoff, or even a chain of handoffs. For example, in a handoff chain <code>User 1 -&gt; Agent A -&gt; Agent B -&gt; Agent C</code>, <code>Agent C</code> still acts on behalf of the <code>User 1</code>. Agent builder The Slack app includes a simple agent builder to create and edit agents from the app's home view. Users can build custom agents by defining their system prompt, model, tools, and criteria for for being activated by background reasoning. For integrating more advanced agents or agentic systems, use the Hybrid Groups Python SDK. Python SDK The Slack and GitHub integrations are built on our Python SDK, which provides the building blocks for developing custom multi-user, multi-agent applications. For interacting with agents, it defines an <code>Agent</code> abstraction that we currently implement with Pydantic AI but it can be replaced with other implementations if desired. Session persistence Group sessions are saved, so they can be resumed after a server restart. This includes all messages and the states of agents and background reasoners. Messages added by users in Slack or GitHub while the server is down are synchronized when sessions are resumed."},{"location":"agent-builder/","title":"Agent builder","text":""},{"location":"agent-builder/#agent-builder","title":"Agent builder","text":"<p>The Hybrid Groups Slack app includes a simple agent builder at the bottom of the app's home view. From there, you can open the agent editor by clicking the <code>Add Agent</code> button or by selecting <code>Edit</code> from an agent's menu. </p> <p>Figure 1: Agent configuration sections in the Hybrid Groups Slack app home view.</p> <p>Figure 2: Editor for configuring the system prompt, model and tools of an agent.</p> <p>In the editor, users can build custom agents by defining their system prompt, model and tools. An agent's description and the agent activation policy (example) determine if an agent is activated by background reasoning.</p> <p>Advanced agents</p> <p>For integrating more advanced agents or agentic systems, use the Hybrid Groups Python SDK.</p>"},{"location":"agent-builder/#model","title":"Model","text":"<p>The model is specified with a PydanticAI model name.</p> <pre><code>\"gemini-2.5-flash\"\n</code></pre>"},{"location":"agent-builder/#model-settings","title":"Model Settings","text":"<p>Model settings can be common model settings or specific to a given provider. The following example shows settings for Google Gemini.</p> <pre><code>{\n  \"google_thinking_config\": {\n    \"thinking_budget\": 2048\n  }\n}\n</code></pre>"},{"location":"agent-builder/#mcp-settings","title":"MCP settings","text":"<p>MCP settings are defined as a JSON array of MCP server configurations. In <code>env</code> or <code>headers</code>, you can use placeholders for values e.g. <code>${VAR_NAME}</code>. These will be substituted at runtime with user secrets or environment variables.</p> <pre><code>[\n  {\n    \"server_config\": {\n      \"command\": \"npx\",\n      \"args\": [\n        \"-y\",\n        \"@modelcontextprotocol/server-brave-search\"\n      ],\n      \"env\": {\n        \"BRAVE_API_KEY\": \"${BRAVE_API_KEY}\"\n      }\n    },\n    \"session_scope\": false\n  }\n]\n</code></pre> <p>The <code>session_scope</code> setting determines the lifecycle of an MCP server and how placeholders are substituted:</p> <ul> <li><code>session_scope: true</code>: The server is started once per session and reused across requests (session scope). This is the recommended and most performant option. It supports substituting placeholders with environment variables.</li> <li><code>session_scope: false</code>: A new server is started for each agent request (request scope). This may be less performant but is required if you need to substitute placeholders with user secrets. It also supports substituting placeholders with environment variables.</li> </ul> <p>Hint</p> <p>The <code>reader</code> and <code>zotero</code> agents in the screenshot above use the readwise-reader-mcp and zotero-mcp servers, respectively. To use them, follow their installation instructions and set the <code>READER_MCP_EXEC</code> and <code>ZOTERO_MCP_EXEC</code> environment variables as required by demo/register_agents.py.</p>"},{"location":"agent-builder/#python-coroutines","title":"Python coroutines","text":"<p>You can configure <code>async</code> Python functions as tools for an agent by specifying their <code>module</code> and <code>function</code> name.</p> <pre><code>[\n  {\n    \"module\": \"examples.weather\",\n    \"function\": \"get_weather_forecast\"\n  }\n]\n</code></pre>"},{"location":"app-server/","title":"App server","text":"<p>TODO</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#development-environment","title":"Development environment","text":"<p>Follow the instructions in DEVELOPMENT.md for setting up the development environment.</p>"},{"location":"installation/#slack-app","title":"Slack app","text":"<p>To set up and install the Hybrid Groups Slack app to your workspace, run the following command:</p> <pre><code>python -m hygroup.setup.apps slack\n</code></pre> <p>This will add the following variables to your <code>.env</code> file:</p> .env<pre><code>SLACK_BOT_TOKEN=...\nSLACK_APP_TOKEN=...\nSLACK_APP_ID=...\n</code></pre> <p>After setup, you must manually add the app to any channels you want it to be active in. You can do this from the channel's menu under <code>Open channel details</code> -&gt; <code>Integrations</code> -&gt; <code>Add apps</code>.</p>"},{"location":"installation/#github-app","title":"GitHub app","text":"<p>To set up and install the Hybrid Groups GitHub app, run this command:</p> <pre><code>python -m hygroup.setup.apps github\n</code></pre> <p>This will add the following variables to your <code>.env</code> file:</p> .env<pre><code>GITHUB_APP_ID=...\nGITHUB_APP_USERNAME=...\nGITHUB_APP_CLIENT_SECRET=...\nGITHUB_APP_WEBHOOK_SECRET=...\nGITHUB_APP_PRIVATE_KEY_PATH=...\nGITHUB_APP_INSTALLATION_ID=...\n</code></pre>"},{"location":"python-sdk/","title":"Python SDK","text":"<p>TODO</p>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#installation","title":"Installation","text":"<p>Follow the installation instructions for setting up the development environment and installing the Slack and GitHub apps.</p>"},{"location":"quickstart/#register-agents","title":"Register agents","text":"<p>Register example agents by running:</p> <pre><code>python demo/register_agents.py\n</code></pre> <p>Without any additional API keys, this will add agents <code>general</code> and <code>weather</code> to the agent registry.</p> <p>Hint</p> <p>Other agents in the demo/register_agents.py script require additional API keys for running their MCP servers. These can be added to <code>.env</code> if sharing API keys among users is acceptable. Otherwise, they should be added as user secrets via the Slack app's home view or programmatically with the Python SDK as demonstrated in demo/register_user.py, for example.</p>"},{"location":"quickstart/#app-server","title":"App server","text":"<p>To serve the Slack app, run:</p> <pre><code>python -m hygroup.scripts.server --gateway slack\n</code></pre> <p>To serve the GitHub app, run:</p> <pre><code>python -m hygroup.scripts.server --gateway github\n</code></pre> <p>The GitHub app server additionally requires a smee.io channel for webhook payload delivery. Start a new channel on the smee.io page, install the smee client and connect to the channel with your <code>channel-id</code>:</p> <pre><code>smee -u https://smee.io/&lt;channel-id&gt; -t http://127.0.0.1:8000/api/v1/github-webhook\n</code></pre>"},{"location":"quickstart/#usage-example","title":"Usage example","text":"<p>Activate the <code>weather</code> agent via background reasoning by entering </p> <pre><code>how's the weather in vienna?\n</code></pre> <ul> <li> <p>in the channel where the Slack app was added:</p> <p> </p> </li> <li> <p>in the description of a new GitHub issue:</p> <p> </p> </li> </ul>"},{"location":"prompts/policy/","title":"Agent activation policy","text":"<pre><code>You are an intelligent routing agent. Your primary function is to analyze messages in a multi-user, multi-agent group chat and determine if a specialized agent should be activated to respond. You must follow the rules below precisely.\n\n## **Your Task**\n\n1. **Analyze the incoming message:** You will receive the last message from a group chat. The message will be in the following XML format:\n\n   ```xml\n   &lt;message sender=\"sender_name\" receiver=\"receiver_name\"&gt;\n   message_content\n   &lt;/message&gt;\n   ```\n\n2. **Consult available agents:** Use the get_registered_agents() tool to get a list of available agents and their descriptions. This is your only knowledge of which agents exist.\n3. **Decide and Respond:** Based on the message content, sender, and the list of available agents, decide if one agent should be activated. Your response **MUST** be a single JSON object with the following structure:\n   **To activate an agent:**\n   ```json\n   {\n       \"agent_name\": \"selected_agent_name\",\n       \"query\": \"a clear and concise query for the agent\",\n   }\n   ```\n   **To skip activation:**\n   ```json\n   {\n       \"agent_name\": null,\n       \"query\": null,\n   }\n   ```\n\n## **Strict Constraints (Non-negotiable Rules)**\n\nYou **MUST** skip activation (\"agent_name\": null) if any of the following conditions are met:\n\n1. **Sender is an Agent:** The sender is one of the names returned by get_registered_agents().\n2. **Sender is \"system\":** The sender attribute is exactly \"system\".\n3. **Direct Agent Mention:** The message_content starts by directly mentioning an agent's name (e.g., @agent_name or agent_name:). This is handled by a different system, so you must ignore it.\n\n## **Selection Rules (Your Decision Logic)**\n\nFollow these principles when deciding whether to select an agent:\n\n1. **Identify Strong Information Need:**\n   * Only activate an agent if the user's message shows a clear, strong need for information or assistance.\n   * This can be an **explicit question** (e.g., \"How do I do X?\", \"What is Y?\").\n   * It can also be an **implicit need**, such as a user expressing confusion, asking for a summary, requesting data, or needing a complex task to be performed.\n   * Do not activate an agent for simple conversational chat, opinions, or social messages.\n2. **Ensure Strong Agent Match:**\n   * The user's identified need must be a very good match for the description of one of the available agents.\n   * If the need is vague or doesn't align well with any agent's capabilities, do not select an agent. It's better to skip than to select the wrong agent.\n3. **Formulate a High-Quality Query:**\n   * If you select an agent, the query you create should be a concise instruction or question that directs the agent's focus. The agent has access to the conversation history, so the query should state the immediate task, relying on the available context.\n</code></pre>"},{"location":"setup/github-integration-guide/","title":"Set up the GitHub Integration","text":"<p>This guide will show you how to integrate Hybrid Groups with GitHub using the GitHub App Manifest Flow. </p>"},{"location":"setup/github-integration-guide/#prerequisites","title":"Prerequisites","text":"<ul> <li>GitHub account (personal or organization)</li> <li>GitHub repository to install the GitHub App</li> </ul>"},{"location":"setup/github-integration-guide/#create-the-github-app","title":"Create the GitHub App","text":""},{"location":"setup/github-integration-guide/#1-start-the-setup-script","title":"1. Start the setup script","text":"<pre><code>python -m hygroup.setup.apps github\n</code></pre> <p>A browser opens to the GitHub App setup page.</p>"},{"location":"setup/github-integration-guide/#2-configure-your-apps-settings","title":"2. Configure your app's settings","text":"<ul> <li>App Name: A Unique identifier (e.g., \"My GitHub Application Agent\"). Becomes <code>@my-github-application-agent</code> when mentioning the GitHub App in issues and PRs.</li> <li>Organization: Your GitHub organization name or leave blank for personal account. </li> <li>Webhook URL: Where GitHub sends events. Use smee.io for local testing.</li> </ul>"},{"location":"setup/github-integration-guide/#3-register-the-app-on-github","title":"3. Register the app on GitHub","text":"<p>Click <code>Register GitHub App</code> to be navigated to GitHub's app creation page, where you can review the name and confirm by clicking <code>Create GitHub App for [your account/org]</code>.</p> <p></p> <p>After successful completion you are redirected back to the setup page.</p> <p></p>"},{"location":"setup/github-integration-guide/#install-the-github-app-to-your-repositories","title":"Install the GitHub App to your repositories","text":""},{"location":"setup/github-integration-guide/#1-begin-installation","title":"1. Begin installation","text":"<p>Click <code>Install GitHub App</code> on the setup page and choose where to install it.</p> <p></p>"},{"location":"setup/github-integration-guide/#2-confirm-permissions","title":"2. Confirm permissions","text":"<p>Select the repositories and review the required permissions, then click <code>Install</code>.</p> <p></p>"},{"location":"setup/github-integration-guide/#3-installation-completed","title":"3. Installation completed","text":"<p>On successful installation you are redirected to the GitHub app installations page.</p> <p></p> <p>Copy the installation ID from the URL of this page.</p> <p></p>"},{"location":"setup/github-integration-guide/#4-complete-installation-setup","title":"4. Complete installation setup","text":"<p>Return to the setup page, enter the installation ID and click <code>Complete</code>.</p>"},{"location":"setup/github-integration-guide/#generated-credentials","title":"Generated Credentials","text":"<p>Upon successful completion of the setup, credentials are automatically saved in your <code>.env</code> file and the GitHub App private key is stored in <code>.secrets/github-apps/{app-name}.pem</code>.</p>"},{"location":"setup/github-integration-guide/#environment-variables","title":"Environment variables","text":"Variable Purpose <code>GITHUB_APP_ID</code> App identifier <code>GITHUB_APP_USERNAME</code> App agent name - use this to interact with the GitHub App in issues and PRs <code>GITHUB_APP_CLIENT_SECRET</code> OAuth authentication secret <code>GITHUB_APP_WEBHOOK_SECRET</code> Webhook verification secret <code>GITHUB_APP_PRIVATE_KEY_PATH</code> Location of private key used for API authentication <code>GITHUB_APP_INSTALLATION_ID</code> Unique ID of the GitHub installation"},{"location":"setup/slack-integration-guide/","title":"Set up the Slack Integration","text":"<p>This guide will show you how to integrate Hybrid Groups with Slack using the Slack App Manifest Flow.</p>"},{"location":"setup/slack-integration-guide/#prerequisites","title":"Prerequisites","text":"<ul> <li>Slack workspace with admin permissions</li> <li>Slack account with ability to create apps</li> </ul>"},{"location":"setup/slack-integration-guide/#create-the-slack-app","title":"Create the Slack App","text":""},{"location":"setup/slack-integration-guide/#1-start-the-setup-script","title":"1. Start the setup script","text":"<pre><code>python -m hygroup.setup.apps slack\n</code></pre> <p>A browser opens to the Slack App setup page.</p>"},{"location":"setup/slack-integration-guide/#2-configure-your-apps-settings","title":"2. Configure your app's settings","text":"<ul> <li>App Name: A unique identifier (e.g., \"My Slack Application Agent\"). Becomes your bot's display name in Slack.</li> <li>Configuration Token: Required to create apps via API. Get this from api.slack.com/apps.</li> </ul>"},{"location":"setup/slack-integration-guide/#3-generate-a-configuration-token","title":"3. Generate a configuration token","text":"<p>Navigate to api.slack.com/apps and find \"Your App Configuration Tokens\" section. Click <code>Generate Token</code> and copy the access token (starts with <code>xoxe</code>).</p> <p></p>"},{"location":"setup/slack-integration-guide/#4-create-the-app-on-slack","title":"4. Create the app on Slack","text":"<p>Paste the configuration token in the setup page and click <code>Create Slack App</code> to create your application with Slack.</p> <p>After successful creation you are redirected to the token configuration page.</p> <p></p>"},{"location":"setup/slack-integration-guide/#configure-authentication-tokens","title":"Configure authentication tokens","text":"<p>Two tokens are required for the Slack integration: - App-Level Token: Enables Socket Mode connections - Bot User OAuth Token: Authenticates API calls</p>"},{"location":"setup/slack-integration-guide/#1-generate-app-level-token","title":"1. Generate App-Level Token","text":"<p>Click <code>Slack App-Level Tokens section</code> on the configuration page to navigate to your app's Basic Information.</p> <p></p> <p>In the App-Level Tokens section: 1. Click <code>Generate Token and Scopes</code> 2. Name your token (e.g., \"App Token\") 3. Add the <code>connections:write</code> scope 4. Click <code>Generate</code> 5. Copy the token (starts with <code>xapp</code>)</p> <p></p> <p>Return to the setup page and paste the App-Level Token.</p>"},{"location":"setup/slack-integration-guide/#2-install-the-app-to-your-workspace","title":"2. Install the app to your workspace","text":"<p>Click <code>Slack Install App section</code> on the configuration page to navigate to the Install App section.</p> <p></p> <p>Click <code>Install to [workspace name]</code> and review the required permissions.</p> <p></p> <p>Click <code>Allow</code> to complete the installation. Copy the generated Bot User OAuth Token (starts with <code>xoxb</code>).</p> <p></p>"},{"location":"setup/slack-integration-guide/#3-complete-installation-setup","title":"3. Complete installation setup","text":"<p>Return to the setup page, ensure both tokens are entered, and click <code>Complete Setup</code>.</p> <p></p>"},{"location":"setup/slack-integration-guide/#generated-credentials","title":"Generated Credentials","text":"<p>Upon successful completion of the setup, credentials are automatically saved in your <code>.env</code> file.</p>"},{"location":"setup/slack-integration-guide/#environment-variables","title":"Environment variables","text":"Variable Purpose <code>SLACK_APP_ID</code> App identifier <code>SLACK_APP_TOKEN</code> Authentication token to receive events from Slack <code>SLACK_BOT_TOKEN</code> Authentication token for API calls"}]}